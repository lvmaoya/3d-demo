<!doctype html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>全景展示 Demo</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    /* 缩略图条容器
       - position: fixed 使其固定在窗口内，随页面滚动不移动
       - bottom/left + translateX 将容器居中并贴近底部
       - display: flex 配合 gap 创建水平缩略图队列
       - z-index 提升层级，确保覆盖在 WebGL 画布之上
       - background 使用半透明黑色，增强缩略图与背景的对比度
       - backdrop-filter: blur 在支持的浏览器下对背景进行模糊，提升可读性
       - max-width 与 overflow-x 控制在小屏幕时可横向滚动 */
    #thumbs {
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.25);
      /* 半透明背景，数值越大越不透明，0.25 提供最低限度的遮罩以增强对比 */
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      /* 轻微白色描边，使容器边界清晰 */
      backdrop-filter: blur(6px);
      /* 背景模糊：突出容器内容，数值越大模糊程度越高 */
      max-width: calc(100vw - 40px);
      overflow-x: auto;
    }

    /* 缩略图样式
       - 固定宽高 + object-fit: cover 保证呈现为等比裁剪，避免图片被拉伸
       - border 与 opacity 让未选中的缩略图略微“淡化”，突出当前选中项
       - transition 提供悬停时的平滑动效 */
    #thumbs img {
      width: 96px;
      height: 56px;
      object-fit: cover;
      border-radius: 8px;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.25);
      opacity: 0.85;
      transition: transform .12s ease, opacity .12s ease, box-shadow .12s ease;
    }

    /* 悬停与选中态
       - hover: 提升不透明度、轻微上移、加阴影以获得“可点”的视觉反馈
       - active: 使用更明显的主题色边框，高亮当前所选缩略图 */
    #thumbs img:hover {
      opacity: 1;
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
    }

    #thumbs img.active {
      opacity: 1;
      border-color: rgba(2, 132, 199, 0.8);
      box-shadow: 0 0 0 2px rgba(2, 132, 199, 0.45);
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>

<body>
  <div id="thumbs"></div>
  <div id="loading"
    style="position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);color:#fff;background:rgba(0,0,0,0.5);padding:12px 16px;border-radius:10px;border:1px solid rgba(255,255,255,0.15);">
    图片加载中…</div>
  <canvas id="c"></canvas>
  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.159.0';
    import { OrbitControls } from 'https://esm.sh/three@0.159.0/examples/jsm/controls/OrbitControls.js';

    // 创建渲染器并绑定画布
    // - antialias: true 抗锯齿，减少边缘锯齿，但会略微增加性能开销
    // - outputColorSpace: 使用 sRGB 颜色空间，确保与大多数显示设备的色彩一致
    // - setPixelRatio: 将渲染像素比限制在 2，避免在高 DPI 设备上过度渲染导致性能问题
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    // 场景与相机
    const scene = new THREE.Scene();
    // PerspectiveCamera(fov, aspect, near, far)
    // - fov 视角（度）：通常在 45-90 之间；值越大视野越广但透视变形更明显
    // - aspect 画布宽高比：应当与 renderer 输出尺寸一致，否则画面会拉伸
    // - near 近裁剪面：距离相机小于该值的几何体会被裁剪掉
    // - far 远裁剪面：距离相机大于该值的几何体会被裁剪掉
    const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    camera.position.set(0, 0, 0.1);

    // 轨道控制器：仅允许旋转，不允许平移
    // - enableZoom: false 为了统一缩放体验，改用自定义 FOV 动画缩放
    // - enablePan: false 禁止平移，保持“原地看四周”的全景体验
    // - rotateSpeed/zoomSpeed 控制交互速度，越大响应越快
    // - enableDamping: true 开启阻尼，使旋转更平滑，避免突兀
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableZoom = false;
    controls.enablePan = false;
    controls.rotateSpeed = 0.3;
    controls.zoomSpeed = 0.5;
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;

    // 全景球体，贴图显示在球体内侧
    // - SphereGeometry 半径为 1，细分度 64×64 足以获得平滑的球面
    // - MeshBasicMaterial 不受光照影响，适合“背景/环境”类贴图
    // - side: THREE.BackSide 指定渲染球体内侧，以便我们把相机放在球内观看
    const geometry = new THREE.SphereGeometry(1, 64, 64);
    const material = new THREE.MeshBasicMaterial({ side: THREE.BackSide, transparent: true, opacity: 1 }); // transparent 开启后才能使用 opacity 做淡入淡出
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    // 第二套材质用于过渡淡入淡出：通过两套材质的透明度交叉来实现平滑切换
    const material2 = new THREE.MeshBasicMaterial({ side: THREE.BackSide, transparent: true, opacity: 0 });
    const mesh2 = new THREE.Mesh(geometry, material2);
    scene.add(mesh2);

    // 全景贴图路径列表：数量可无限扩展
    // - id 用于标识与状态管理
    // - src 指向 equirectangular（等距矩形）全景图，建议比例 2:1（如 4000×2000）
    //   分辨率越高细节越好，但显存与加载时间也会增加
    const textures = [
      { id: 'pano1', src: 'assets/97b16f01995764d14ac91aa435604bec.jpg' },
      { id: 'pano2', src: 'assets/a98b0e5cee1b778588ae6b48e5643b72.jpg' },
      { id: 'pano3', src: 'assets/beea51b1dbe12ccd4f47349bc4489e1a.jpg' }
    ];

    // 纹理加载器与缓存引用，避免重复加载
    // - texCache 使用 Map 缓存已经加载过的纹理，减少网络与解码开销
    const loader = new THREE.TextureLoader();
    const texCache = new Map();
    let currentId = null;
    let transition = null;

    // 统一配置纹理参数
    // - colorSpace: sRGB 与渲染器一致，保证颜色正确
    // - minFilter/magFilter: LinearFilter 保证缩放时平滑（不产生像素化）
    // - generateMipmaps: false 因为我们不进行 wrap 重复采样，不需要 mipmap
    // - wrapS/wrapT: S 方向使用 RepeatWrapping 以便进行水平翻转；T 方向使用 ClampToEdge 避免边缘拉伸
    // - repeat.x = -1 与 offset.x = 1 配合，完成水平镜像纠正（将原图左右倒置）
    // - anisotropy: 使用设备支持的最大各向异性，提升贴图斜角清晰度
    function setupTexture(t) {
      t.colorSpace = THREE.SRGBColorSpace;
      t.minFilter = THREE.LinearFilter;
      t.magFilter = THREE.LinearFilter;
      t.generateMipmaps = false;
      t.wrapS = THREE.RepeatWrapping;
      t.wrapT = THREE.ClampToEdgeWrapping;
      t.repeat.x = -1;
      t.offset.x = 1;
      t.anisotropy = renderer.capabilities.getMaxAnisotropy();
    }

    // 直接切换贴图（不做过渡）
    // - 立即替换 material.map 并重置过渡材质
    // - 隐藏“加载中”提示
    function applyTextureImmediate(t) {
      material.map = t;
      material.opacity = 1;
      material.needsUpdate = true;
      material2.opacity = 0;
      material2.map = null;
      document.getElementById('loading').style.display = 'none';
    }

    // 过渡切换贴图（交叉淡出）
    // - 将目标纹理挂到第二套材质上，并记录过渡开始时间与时长
    // - animate 中根据时间线性混合两套材质的透明度，实现淡入淡出
    function crossfadeTo(t) {
      material2.map = t;
      material2.opacity = 0;
      material2.needsUpdate = true;
      transition = { start: performance.now(), duration: 300, target: t };
    }

    // 根据 id 加载贴图并回调
    // - 若缓存中已有，则直接回调；否则发起加载并在 onLoad 中回调
    // - TextureLoader 异步解码图片，避免卡顿
    function loadTextureById(id, cb) {
      const info = textures.find(x => x.id === id);
      if (!info) return;
      if (texCache.has(id)) {
        cb && cb(texCache.get(id));
        return;
      }
      const t = loader.load(info.src, () => {
        setupTexture(t);
        texCache.set(id, t);
        cb && cb(t);
      });
    }

    // 单次渲染，用于首帧显示
    function renderOnce() {
      renderer.render(scene, camera);
    }

    // 鼠标滚轮平滑缩放
    // - 通过修改相机 FOV（视角）实现缩放效果，比直接放大/缩小相机位置更适合全景浏览
    // - 使用 fovTarget + 插值（ease）来避免突兀的跳变
    let fovTarget = camera.fov;
    const fovMin = 30, fovMax = 100, fovEase = 0.15;
    renderer.domElement.addEventListener('wheel', (e) => {
      e.preventDefault(); // 阻止浏览器默认滚动行为，避免页面滚动影响体验
      const delta = -e.deltaY;
      fovTarget = THREE.MathUtils.clamp(fovTarget + delta * 0.05, fovMin, fovMax);
    }, { passive: false });

    // 创建底部缩略图按钮
    // - 每个缩略图绑定 click 事件，点击后加载对应纹理并进行切换
    // - 使用 active 类名高亮当前选中的缩略图
    function buildThumbs() {
      const wrap = document.getElementById('thumbs');
      wrap.innerHTML = '';
      textures.forEach((x, i) => {
        const img = document.createElement('img');
        img.src = x.src;
        img.alt = x.id; // 无障碍：为图片提供替代文本
        img.dataset.id = x.id; // 将 id 存到 dataset，便于调试与扩展
        img.addEventListener('click', () => {
          document.querySelectorAll('#thumbs img').forEach(el => el.classList.remove('active'));
          img.classList.add('active');
          document.getElementById('loading').style.display = '';
          loadTextureById(x.id, (tex) => {
            if (currentId === null) {
              applyTextureImmediate(tex);
            } else {
              crossfadeTo(tex);
            }
            currentId = x.id;
          });
        });
        if (i === 0) img.classList.add('active');
        wrap.appendChild(img);
      });
    }
    buildThumbs();
    // 初始加载第一张，完成后立即渲染首帧
    loadTextureById(textures[0].id, (tex) => {
      applyTextureImmediate(tex);
      currentId = textures[0].id;
      renderOnce();
    });

    // 自适应窗口尺寸
    // - 根据窗口大小调整渲染器与相机的宽高比，避免画面被拉伸
    function resize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }

    window.addEventListener('resize', resize);
    resize();

    // 主渲染循环：更新控制器、缩放与过渡
    // - 使用 requestAnimationFrame 逐帧更新
    // - controls.update() 应用阻尼与旋转
    // - FOV 插值实现平滑缩放
    // - 若存在 transition，根据时间混合两套材质透明度来完成交叉淡出
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      if (Math.abs(fovTarget - camera.fov) > 0.01) {
        camera.fov += (fovTarget - camera.fov) * fovEase;
        camera.fov = THREE.MathUtils.clamp(camera.fov, fovMin, fovMax);
        camera.updateProjectionMatrix();
      }
      // 过渡混合两套材质的透明度
      if (transition) {
        const p = Math.min(1, (performance.now() - transition.start) / transition.duration); // 0→1 的进度值
        material.opacity = 1 - p;
        material2.opacity = p;
        if (p === 1) {
          material.map = transition.target;
          material.opacity = 1;
          material2.opacity = 0;
          material2.map = null;
          transition = null;
          document.getElementById('loading').style.display = 'none';
        }
      }
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>

</html>